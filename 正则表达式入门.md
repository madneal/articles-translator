

https://medium.com/factory-mind/regex-tutorial-a-simple-cheatsheet-by-examples-649dc1c3f285
## 正则表达式入门 — 一个通过例子来说明的备忘单

![](https://cdn-images-1.medium.com/max/2560/0*qASU92GfMj2HCTMg.jpg)

Regular expressions (regex or regexp) are extremely useful in **extracting information from any text** by searching for one or more matches of a specific search pattern (i.e. a specific sequence of ASCII or unicode characters).

正则表达式（regex或regexp）在通过搜索特定搜索模式的一个或多个匹配（即 ASCII 或 unicode 字符的特定序列）**从任何文本中提取信息时非常有用。

Fields of application range from validation to parsing/replacing strings, passing through translating data to other formats and web scraping.

One of the most interesting features is that once you’ve learned the syntax, you can actually use this tool in (almost) all programming languages ​​(JavaScript, Java, VB, C #, C / C++, Python, Perl, Ruby, Delphi, R, Tcl, and many others) with the slightest distinctions about the support of the most advanced features and syntax versions supported by the engines).

Let’s start by looking at some examples and explanations.

应用领域从验证到解析/替换字符串，将数据转换为其他格式以及网络爬虫。

最有趣的功能之一是，一旦你学会了语法，你就可以在（几乎）所有编程语言中使用这个工具（JavaScript，Java，VB，C＃，C / C ++，Python，Perl，Ruby，Delphi，R，Tcl等等），对引擎支持的最高级功能和语法版本的支持有一点区别）。

让我们首先看一些例子和解释。

## 基本知识点

### **锚 — ^ 以及 $**

    **^The**       匹配任意字符串以 **The 为开头**-> **[试一下!](https://regex101.com/r/cO8lqs/2)**

    **end$**       匹配任意字符串以** end 为结尾**

    **^The end$    匹配字符串的(开头和结尾分别是 **The end**)

    **roar**       匹配任意具有 **roar** 的字符串

### **量词 — * + ? and {}**

    abc*****       匹配一个字符串具有 **ab 其后有0个或者多个 c**->**[试一下!](https://regex101.com/r/cO8lqs/1)**

    abc**+**       匹配一个字符串具有 **ab 其后有1个或者多个 c**-

    abc**?**       匹配一个字符串具有 **ab 其后有0个或者1个 c**-

    abc**{2}**     匹配一个字符串具有 **ab 其后有2个 c**-

    abc**{2,}**    匹配一个字符串具有 **ab 其后有2个或者多个 c**-

    abc**{2,5}**   匹配一个字符串具有 **ab 其后有2到5个 c**-

    a**(bc)*       匹配一个字符串具有 **a 其后有0到多个 bc 的副本**

    a**(bc){2,5}   匹配一个字符串具有 **a 其后有0到5个 bc 的副本**

### OR 操作符 — | or []

    **a(b|c)**     匹配一个字符串具有 **a 其后有 b 或者 c -> [试一下!](https://regex101.com/r/cO8lqs/3)**

    **a[bc]**      与上一条相同

### 字符类 — \d \w \s and .

    **\d**         匹配一个**数字**字符-> **[试一下!](https://regex101.com/r/cO8lqs/4)**

    **\w**         匹配一个**单词字符**(字母以及下划线) -> [试一下!](https://regex101.com/r/cO8lqs/4)**

    **\s**         匹配**空白字符**(包括 tab 以及换行)

    **.**          匹配**任意字符**->[试一下!](https://regex101.com/r/cO8lqs/5)**

Use the . operator carefully since often class or negated character class (which we’ll cover next) are faster and more precise.

仔细使用 . 操作符，因为类或者否定类字符（我们在下面会提到）将会更快更准确。

\d, \w 以及 \s 分别对应其否定类 \D, \W 以及 \S 。

例如, \ D将执行与\ d获得的相反的匹配。

    **\D**         匹配一个**非数字字符**->[试一下!](https://regex101.com/r/cO8lqs/6)**

In order to be taken literally, you must escape the characters ^.[$()|*+?{\with a backslash \ as they have special meaning.

为了获取字面上疑似的字符，你必须使用反斜杠 \ 来转义字符 ^.[$()|*+?{\，因为它们具有特殊含义。

    **\$\d***       匹配一个字符具有一个数字字符其前面是一个 $>[试一下!](https://regex101.com/r/cO8lqs/9)**

Notice that you can match also **non-printable characters** like tabs \t, new-lines \n, carriage returns \r.

注意你也可以匹配**非打印字符**比如 tabs \t，换行 \n，回车 \r。

### 标志

We are learning how to construct a regex but forgetting a fundamental concept: **flags**.

我们正在学习如何构建一个正则表达式但是却忘记了一个基础的概念：**标志**。

A regex usually comes with in this form `**/**abc**/**`, where the search pattern is delimited by two slash characters /. At the end we can specify a flag with these values (we can also combine them each other):

一个正则表达式的格式通常是这个样子的 `**/**abc**/**`，搜索模式通过两个斜杠符 `/` 进行区分。在末尾我们可以规定一个标志使用以下的值（我们也可以将它们相互结合）：

* **g**(全局的) does not return after the first match, restarting the subsequent searches from the end of the previous match在第一匹配之后不会立即返回，从前面匹配之后继续搜索

* **m** (多行的) when enabled ^ and $ will match the start and end of a line, instead of the whole string当使用 `^` 以及 `$` 的时候将会匹配行首和行尾而不是整个字符串

* **i** (大小写不敏感的) makes the whole expression case-insensitive (for instance **/aBc/i** would match **AbC**) 让整个表达式大小写不敏感（比如 `/**aBc**/**i**` 将匹配 `**Abc**`）

## 中级知识点

### 分组以及捕获 — ()

    a**(**bc**)**           parentheses create a **capturing group with value bc **-> **[Try it!](https://regex101.com/r/cO8lqs/11)**

    a**(?:**bc**)***        using **?:** we **disable the capturing group **-> **[Try it!](https://regex101.com/r/cO8lqs/12)**

    a**(?<foo>**bc**)**     using **?<foo>** we put a name to the group -> [**Try it!](https://regex101.com/r/cO8lqs/17)**

This operator is very useful when we need to extract information from strings or data using your preferred programming language. Any multiple occurrences captured by several groups will be exposed in the form of a classical array: we will access their values specifying using an index on the result of the match.

If we choose to put a name to the groups (using (**?<foo>**...)) we will be able to retrieve the group values using the match result like a dictionary where the keys will be the name of each group.

### Bracket expressions — []

    **[abc]**            matches a string that has **either an a or a b or a c **-> ****is the **same as a|b|c **-> **[Try it!](https://regex101.com/r/cO8lqs/7)**

    **[a-c]            **same as previous

    **[a-fA-F0-9]      **a string that represents **a single hexadecimal digit, case insensitively **-> **[Try it!](https://regex101.com/r/cO8lqs/22)**

    **[0-9]%           **a string that has a character **from 0 to 9 before a % sign**

    **[^a-zA-Z]**        a string that has **not a letter from a to z or from A to Z. **In this case the **^** is used as **negation of the expression **-> **[Try it!](https://regex101.com/r/cO8lqs/10)**

Remember that inside bracket expressions all special characters (including the backslash \) lose their special powers: thus we will not apply the “escape rule”.

### Greedy and Lazy match

The quantifiers ( * + {}) are greedy operators, so they expand the match as far as they can through the provided text.

For example, <.+> matches <div>simple div</div> in This is a **<div> simple div</div>** test. In order to catch only the div tag we can use a ? to make it lazy:

    **<.+?>**            matches **any character one or more** times included **inside <** and **>**, **expanding as needed **-> **[Try it!](https://regex101.com/r/cO8lqs/24)**

Notice that a better solution should avoid the usage of . in favor of a more strict regex:

    **<[^<>]+>         **matches **any character except < or > one or more **times included **inside <** and **> **-> **[Try it!](https://regex101.com/r/cO8lqs/23)**

## Advanced topics

### **Boundaries — \b and \B**

    **\b**abc**\b          **performs a **"whole words only" search **-> **[Try it!](https://regex101.com/r/cO8lqs/25)**

\b represents an **anchor like caret** (it is similar to $ and ^) matching positions where **one side is a word** **character **(like \w) and the **other side is not a word** **character **(for instance it may be the beginning of the string or a space character).

It comes with the its **negation**, \B. This matches all positions where \b doesn’t match and could be if we want to find a search pattern fully surrounded by word characters.

    **\B**abc**\B          **matches only if the pattern is **fully surrounded by word** characters -> [**Try it!](https://regex101.com/r/cO8lqs/26)**

### Back-references — \1

    **(**[abc]**)\1**              using **\1** it matches **the same** text **that was matched by the first capturing group **-> **[Try it!](https://regex101.com/r/cO8lqs/14)**

    ([abc])**(**[de]**)\2**\1      we can use **\2** (\3, \4, etc.) to identify **the same** text that **was matched by the second **(third, fourth, etc.) **capturing group **-> **[Try it!](https://regex101.com/r/cO8lqs/15)**

    **(?<foo>**[abc]**)\k<foo>   **we put the name **foo t**o the group and we reference it later (**\k<foo>**). The result is the same of the first regex -> [**Try it!](https://regex101.com/r/cO8lqs/16)**

### Look-ahead and Look-behind — **(?=)** and **(?<=)**

    d**(?=**r**)**       matches a **d **only if is **followed by r**, **but r will not be** part of the overall regex **match **-> **[Try it!](https://regex101.com/r/cO8lqs/18)**

    **(?<=**r**)**d      matches a **d **only if is **preceded by an r**, **but r will not be** part of the overall regex **match **-> **[Try it!](https://regex101.com/r/cO8lqs/19)**

You can use also the negation operator !

    d**(?!**r**)       **matches a **d **only if is **not followed by r**, **but r will not be** part of the overall regex **match **-> **[Try it!](https://regex101.com/r/cO8lqs/20)**

    **(?<!**r**)**d      matches a **d **only if is **not preceded by an r**, **but r will not be** part of the overall regex **match **-> **[Try it!](https://regex101.com/r/cO8lqs/21)**

## Summary

As you’ve seen, the application fields of regex can be multiple and I’m sure that you’ve recognized at least one of these tasks among those seen in your developer career, here a quick list:

* data validation (for example check if a time string i well-formed)

* data scraping (expecially web scraping, find all pages that contain a certain set of words eventually in a specific order)

* data wrangling (transform data from “raw” to another format)

* string parsing (for example catch all url’s GET parameters, capture text inside a set of parenthesis)

* string replacement (even during a code session using a common IDE, for example tranform a Java or C# class in the correspective JSON object — replace “;” with “,” make it lowercase, avoid type declaration, etc.)

* syntax highlightning, file renaming, packet sniffing and many other applications involving strings (where data need not be textual)

Have fun and do not forget to recommend the article if you liked it 💚

**Soon I will publish a new article containing a list of common Regex, stay tuned!**
