# Ê∑±ÂÖ•ÁêÜËß£ JavaScript ‰∏≠ÁöÑÈó≠ÂåÖ

>ÂéüÊñáÔºö[JavaScript - Closure in depth](https://www.debuggr.io/js-closure-in-depth/)
>
>ËØëËÄÖÔºö[neal1991](https://github.com/neal1991)
>
>welcome to star my [articles-translator](https://github.com/neal1991/articles-translator/), providing you advanced articles translation. Any suggestion, please issue or contact [me](mailto:bing@stu.ecnu.edu.cn)
>
>LICENSE: [MIT](https://opensource.org/licenses/MIT)

In this article we will learn about the concept of closures in JavaScript, we will see how functions can be stateful with persistent data across multiple executions. We will also explore some of the popular use cases of closure and different approaches for using them.

Lets start with a quote from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures):

> A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words, a closure gives you access to an outer function‚Äôs scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.

If you ask me, i would say that closures enables us to create stateful functions.

Âú®Êú¨Êñá‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂ≠¶‰π† JavaScript ‰∏≠Èó≠ÂåÖÁöÑÊ¶ÇÂøµÔºåÊàë‰ª¨Â∞Ü‰∫ÜËß£ÂÖ∑ÊúâÊåÅ‰πÖÂåñÊï∞ÊçÆÂáΩÊï∞Â¶Ç‰ΩïÂú®Â§ö‰∏™ÊâßË°å‰∏≠ÁöÑÂÆûÁé∞Áä∂ÊÄÅÂåñ„ÄÇÊàë‰ª¨ËøòÂ∞ÜÊé¢ËÆ®Èó≠ÂåÖÁöÑ‰∏Ä‰∫õÊµÅË°åÁî®‰æã‰ª•ÂèäÂÆÉ‰ª¨ÁöÑ‰∏çÂêå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ

ËÆ©Êàë‰ª¨ÂÖàÁúã‰∏ÄÊÆµ [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) ‰∏≠ÁöÑ‰ªãÁªçÔºö

> Èó≠ÂåÖÊòØÊâìÂåÖÂú®‰∏ÄËµ∑ÔºàÂ∞ÅÈó≠ÔºâÁöÑÂáΩÊï∞ÂèäÂÖ∂Âë®Âõ¥Áä∂ÊÄÅÔºàËØçÊ≥ïÁéØÂ¢ÉÔºâÁöÑÁªÑÂêà„ÄÇÊç¢Âè•ËØùËØ¥ÔºåÈó≠ÂåÖ‰Ωø‰Ω†ÂèØ‰ª•‰ªéÂÜÖÈÉ®ÂáΩÊï∞ËÆøÈóÆÂ§ñÈÉ®ÂáΩÊï∞ÁöÑ‰ΩúÁî®Âüü„ÄÇÂú® JavaScript ‰∏≠ÔºåÊØèÊ¨°ÂàõÂª∫ÂáΩÊï∞Êó∂ÈÉΩ‰ºöÂú®ÂáΩÊï∞ÂàõÂª∫Êó∂ÂàõÂª∫Èó≠ÂåÖ„ÄÇ

Â¶ÇÊûú‰Ω†ÈóÆÊàëÔºåÊàë‰ºöËØ¥Èó≠ÂåÖ‰ΩøÊàë‰ª¨ËÉΩÂ§üÂàõÂª∫Áä∂ÊÄÅÂáΩÊï∞„ÄÇ

## Stateful functions

## Áä∂ÊÄÅÂáΩÊï∞

Stateful functions are functions that can ‚Äúremember‚Äù data from previous executions. For example lets create a function that ‚Äúremembers‚Äù and count how many times it got executed, each time that we will invoke it, it will log the number of times it got executed.

To do that, we will need some kind of a counter variable that will hold the current number of executions and will get incremented every time we invoke the function, the challenge here is to decide on where to put this variable.

Lets explore our first approach:

Áä∂ÊÄÅÂáΩÊï∞ÂèØ‰ª•‚ÄúËÆ∞‰Ωè‚Äù‰πãÂâçÊâßË°å‰∏≠ÁöÑÊï∞ÊçÆ„ÄÇ‰æãÂ¶ÇÔºåËÆ©Êàë‰ª¨ÂàõÂª∫‰∏Ä‰∏™‚ÄúËÆ∞‰Ωè‚ÄùÂπ∂ÁªüËÆ°ÊâßË°åÊ¨°Êï∞ÁöÑÂáΩÊï∞ÔºåÊØèÊ¨°Ë∞ÉÁî®ËØ•ÂáΩÊï∞Êó∂ÔºåÂÆÉÈÉΩ‰ºöËÆ∞ÂΩïÊâßË°åÊ¨°Êï∞„ÄÇ

‰∏∫Ê≠§ÔºåÊàë‰ª¨Â∞ÜÈúÄË¶ÅÊüêÁßçËÆ°Êï∞Âô®ÂèòÈáèÔºåËØ•ËÆ°Êï∞Âô®ÂèòÈáèÂ∞Ü‰øùÂ≠òÂΩìÂâçÁöÑÊâßË°åÊ¨°Êï∞ÔºåÂπ∂‰∏îÊØèÊ¨°Ë∞ÉÁî®ËØ•ÂáΩÊï∞Êó∂ÈÉΩ‰ºöÈÄíÂ¢ûËÆ°Êï∞ÔºåËøôÈáåÁöÑÊåëÊàòÊòØÁ°ÆÂÆöÂ∞ÜËØ•ÂèòÈáèÊîæÂú®‰ΩïÂ§Ñ„ÄÇ

ËÆ©Êàë‰ª¨Êé¢Á¥¢Êàë‰ª¨ÁöÑÁ¨¨‰∏ÄÁßçÊñπÊ≥ïÔºö

```
function counter(){
  let numOfExecutions = 0;
  numOfExecutions++;
  console.log(numOfExecutions);
}

counter() // 1
counter() // 1
```

Obviously this won‚Äôt work well, because we are re-creating the numOfExecutions variable every time we invoke counter().

ÊòæÁÑ∂ÔºåËøô‰∏™ÊñπÊ≥ïË°å‰∏çÈÄöÔºåÂõ†‰∏∫ÊØèÊ¨°Ë∞ÉÁî® `counter()` Êó∂ÔºåÊàë‰ª¨ÈÉΩ‰ºöÈáçÊñ∞ÂàõÂª∫ `numOfExecutions` ÂèòÈáè„ÄÇ

## Execution context

Every time we invoke a function, a new execution context is created, and each execution context has it‚Äôs own ‚ÄúVariable Environment‚Äù or ‚Äúscope‚Äù if you will. This local variable environment is holding all arguments that got passed to it and all declarations made inside the body of the function, in our case the numOfExecutions variable. When the function is ‚Äúdone‚Äù, e.g with a return statement or there are no more lines of code to execute, the engine will mark it to be garbage collected, meaning it‚Äôs entire environment will get disposed.

This is the reason our code above doesn‚Äôt work well, every time we invoke counter we create a new execution context with a new declaration of the numOfExecutions variable and incrementing it to the value of 1.

## ÊâßË°å‰∏ä‰∏ãÊñá

ÊØèÊ¨°Ë∞ÉÁî®ÂáΩÊï∞Êó∂ÔºåÈÉΩ‰ºöÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÊâßË°å‰∏ä‰∏ãÊñáÔºåÂπ∂‰∏îÊØè‰∏™ÊâßË°å‰∏ä‰∏ãÊñáÈÉΩÊúâËá™Â∑±ÁöÑ‚ÄúÂèòÈáèÁéØÂ¢É‚ÄùÊàñ‚Äú‰ΩúÁî®Âüü‚Äù„ÄÇËøô‰∏™Â±ÄÈÉ®ÂèòÈáèÁéØÂ¢É‰øùÂ≠òÁùÄ‰º†ÈÄíÁªôÂÆÉÁöÑÊâÄÊúâÂèÇÊï∞‰ª•ÂèäÂú®ÂáΩÊï∞‰ΩìÂÜÖËøõË°åÁöÑÊâÄÊúâÂ£∞ÊòéÔºåÂú®Êàë‰ª¨ÁöÑ‰æãÂ≠ê‰∏≠ÊòØ `numOfExecutions` ÂèòÈáè„ÄÇÂΩìÂáΩÊï∞‚ÄúÂÆåÊàê‚ÄùÊó∂Ôºà‰æãÂ¶ÇÔºå‰ΩøÁî® return ËØ≠Âè•ÊàñÊ≤°ÊúâÂÖ∂ÂÆÉÊâßË°å‰ª£Á†ÅÔºâÔºåÂºïÊìé‰ºöÂ∞ÜÂÖ∂Ê†áËÆ∞‰∏∫ÂûÉÂúæÂõûÊî∂ÔºåËøôÊÑèÂë≥ÁùÄÊï¥‰∏™ÁéØÂ¢ÉÈÉΩÂ∞ÜË¢´‰∏¢ÂºÉ„ÄÇ

ËøôÂ∞±ÊòØÊàë‰ª¨‰∏äÈù¢ÁöÑ‰ª£Á†ÅÊó†Ê≥ïÊ≠£Â∏∏Â∑•‰ΩúÁöÑÂéüÂõ†ÔºåÊØèÊ¨°Êàë‰ª¨Ë∞ÉÁî®ËÆ°Êï∞Âô®Êó∂ÔºåÊàë‰ª¨ÈÉΩ‰ºö‰ΩøÁî® `numOfExecutions` ÂèòÈáèÁöÑÊñ∞Â£∞ÊòéÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÊâßË°å‰∏ä‰∏ãÊñáÔºåÂπ∂Â∞ÜÂÖ∂ÈÄíÂ¢û‰∏∫1„ÄÇ

## Global execution context

When we start our program, the engine will create a global execution context for us, its not different from the execution context we create when we invoke a function. It also has a ‚ÄúVariable Environment‚Äù just like any other execution context, the difference is that the global execution context will never ‚Äúdie‚Äù (as long as our program is running of course), hence it‚Äôs variable environment won‚Äôt get disposed by the garbage collector.

So knowing that, we can maybe store our numOfExecutions in the global variable environment, this way we know it won‚Äôt get re-created each time we invoke counter.

## ÂÖ®Â±ÄÊâßË°å‰∏ä‰∏ãÊñá

ÂΩìÊàë‰ª¨ÂêØÂä®Á®ãÂ∫èÊó∂ÔºåÂºïÊìéÂ∞Ü‰∏∫Êàë‰ª¨ÂàõÂª∫‰∏Ä‰∏™ÂÖ®Â±ÄÊâßË°å‰∏ä‰∏ãÊñáÔºåÂÆÉ‰∏éË∞ÉÁî®ÂáΩÊï∞Êó∂ÂàõÂª∫ÁöÑÊâßË°å‰∏ä‰∏ãÊñáÂ∑Æ‰∏çÂ§ö„ÄÇÂ∞±ÂÉè‰ªª‰ΩïÂÖ∂‰ªñÊâßË°å‰∏ä‰∏ãÊñá‰∏ÄÊ†∑ÔºåÂÆÉ‰πüÂÖ∑Êúâ‚ÄúÂèòÈáèÁéØÂ¢É‚ÄùÔºå‰∏çÂêå‰πãÂ§ÑÂú®‰∫éÂÖ®Â±ÄÊâßË°å‰∏ä‰∏ãÊñáÊ∞∏Ëøú‰∏ç‰ºö‚ÄúÊ∂à‰∫°‚ÄùÔºàÂΩìÁÑ∂Âè™Ë¶ÅÊàë‰ª¨ÁöÑÁ®ãÂ∫èÊ≠£Âú®ËøêË°åÔºâÔºåÂõ†Ê≠§ÂÆÉÁöÑÂèòÈáèÁéØÂ¢É‰∏ç‰ºöË¢´ÂõûÊî∂„ÄÇ

Âõ†Ê≠§Áü•ÈÅìÔºåÊàë‰ª¨ÂèØ‰ª•Â∞Ü `numOfExecutions` Â≠òÂÇ®Âú®ÂÖ®Â±ÄÂèòÈáèÁéØÂ¢É‰∏≠ÔºåËøôÊ†∑Êàë‰ª¨Â∞±Áü•ÈÅìÊØèÊ¨°Ë∞ÉÁî® `counter` Êó∂ÈÉΩ‰∏ç‰ºöÈáçÊñ∞ÂàõÂª∫ÂÆÉ„ÄÇ

```
let numOfExecutions = 0;

function counter(){
  numOfExecutions++;
  console.log(numOfExecutions);
}

counter() // 1
counter() // 2
```

This works as we expect, we get the correct number of invocations, but you probably already know that storing variables on the global environment is considered as bad practice. For example see what happens if another function wants to use the exact same variable:

ËøôÂèØ‰ª•ÊåâÊàë‰ª¨È¢ÑÊúüÁöÑÈÇ£Ê†∑Â∑•‰ΩúÔºåÂèØ‰ª•ÂæóÂà∞Ê≠£Á°ÆÁöÑË∞ÉÁî®Ê¨°Êï∞Ôºå‰ΩÜÊòØ‰Ω†ÂèØËÉΩÂ∑≤ÁªèÁü•ÈÅìÔºåÂ∞ÜÂèòÈáèÂ≠òÂÇ®Âú®ÂÖ®Â±ÄÁéØÂ¢É‰∏≠Ë¢´ËÆ§‰∏∫ÊòØ‰∏çÊ≠£Á°ÆÁöÑÂÅöÊ≥ï„ÄÇ‰æãÂ¶ÇÔºåÁúãÁúãÂè¶‰∏Ä‰∏™ÂáΩÊï∞ÊÉ≥Ë¶Å‰ΩøÁî®ÂÆåÂÖ®Áõ∏ÂêåÁöÑÂèòÈáè‰ºöÂèëÁîü‰ªÄ‰πàÔºö

```
let numOfExecutions = 0;

function counter() {
  numOfExecutions++;
  console.log(numOfExecutions);
}

function someFunc() {
  numOfExecutions = 100;
}

someFunc()
counter() // 101
counter() // 102
```

As you can see we get some wrong numbers in here.

Another issue with this approach is that we can‚Äôt run more than 1 instance of counter.

## Lexical Scope

Lexical Scope is basically a fancy way of saying ‚ÄúStatic Scope‚Äù, meaning we know at creation time what is the scope of our function.

Read this carefully:

> **WHERE** you define your function, determines what variables the function have access to **WHEN** it gets called.

In other words, it doesn‚Äôt matter where and how you invoke the function, its all about where did it got declared.

But how do we declare a function in one place, and invoke it in another place? Well, we can create a function within a function and return it:

Â¶Ç‰Ω†ÊâÄËßÅÔºåÊàë‰ª¨Âú®ËøôÈáåÂæóÂà∞‰∏Ä‰∫õÈîôËØØÁöÑÊï∞Â≠ó„ÄÇ

ËøôÁßçÊñπÊ≥ïÁöÑÂè¶‰∏Ä‰∏™ÈóÆÈ¢òÊòØÔºåÊàë‰ª¨‰∏çËÉΩËøêË°å‰∏Ä‰∏™‰ª•‰∏äÁöÑ `counter` ÂÆû‰æã„ÄÇ

## ËØçÊ≥ï‰ΩúÁî®Âüü

ËØçÊ≥ï‰ΩúÁî®ÂüüÂü∫Êú¨‰∏äÊòØËØ¥‚ÄúÈùôÊÄÅËåÉÂõ¥‚ÄùÁöÑ‰∏ÄÁßçÈ´òÁ∫ßËØ¥Ê≥ïÔºåËøôÊÑèÂë≥ÁùÄÊàë‰ª¨Âú®ÂàõÂª∫Êó∂Â∞±Áü•ÈÅìÂáΩÊï∞ÁöÑ‰ΩúÁî®ÂüüÊòØ‰ªÄ‰πà„ÄÇ

ËØ∑‰ªîÁªÜÈòÖËØª‰ª•‰∏ãÂÜÖÂÆπÔºö

> Âú®‰ΩïÂ§ÑÂÆö‰πâÂáΩÊï∞ÔºåÂ∞±ÂÜ≥ÂÆö‰∫ÜÂáΩÊï∞Âú®Ë¢´Ë∞ÉÁî®Êó∂ÂèØ‰ª•ËÆøÈóÆÂì™‰∫õÂèòÈáè„ÄÇ

Êç¢Âè•ËØùËØ¥ÔºåÊó†ËÆ∫Âú®‰ΩïÂ§Ñ‰ª•ÂèäÂ¶Ç‰ΩïË∞ÉÁî®ÂáΩÊï∞ÔºåÈÉΩ‰∏éÂú®‰ΩïÂ§ÑÂ£∞ÊòéÂáΩÊï∞Êó†ÂÖ≥„ÄÇ

‰ΩÜÊòØÔºåÊàë‰ª¨Â¶Ç‰ΩïÂú®‰∏Ä‰∏™Âú∞ÊñπÂ£∞Êòé‰∏Ä‰∏™ÂáΩÊï∞ÔºåÁÑ∂ÂêéÂú®Âè¶‰∏Ä‰∏™Âú∞ÊñπË∞ÉÁî®ÂÆÉÂë¢Ôºü Â•ΩÂêßÔºåÊàë‰ª¨ÂèØ‰ª•Âú®‰∏Ä‰∏™ÂáΩÊï∞ÂÜÖÂàõÂª∫‰∏Ä‰∏™ÂáΩÊï∞Âπ∂ËøîÂõûÂÆÉÔºö

```
function createFunc() {
  function newFunc(){
  
  }
  
  return newFunc;
}

const myFunc = createFunc();
myFunc()
```

It may seem useless, but lets explore the execution phase of our program:

1. We declare a new function with the createFunc label in the global variable environment.
2. We declare a new variable myFunc in the global variable environment which it‚Äôs value will be the returned value from the execution of createFunc.
3. We invoke the createFunc function.
4. A new execution context is created (with a local variable environment).
5. We declare a function and giving it a label of newFunc (stored in the local variable environment of createFunc).
6. We return newFunc.
7. The returned value from createFunc is stored as the value of myFunc in the global variable environment.
8. The variable environment of createFunc is marked for disposal (meaning the newFunc variable will not exist).
9. We invoke myFunc.

Note that when we return the function newFunc, we return the actual function definition, not the label.

OK, so what can we do with this approach?

It turns out, that when we return a function, we are not only returning our function definition but we also return it‚Äôs entire lexical environment. I.e, if we had some variable declared in the same context (or outer contexts), our returned function would close over them, and keep a reference to them.

Lets see that in action with our counter example:

```
function createCounter() {
  // creating a wrapping execution context
  // so we won't pollute the global environment
  let numOfExecutions = 0;

  // creating and returning an inner function
  // that closes over the lexical environment
  function counter() {
    numOfExecutions++;
    console.log(numOfExecutions);
  }

  return counter;
}

const counter = createCounter();

counter() // 1
counter() // 2
```

As you can see, we are creating a wrapper execution context (createCounter) to store our numOfExecutions variable and we are returning the counter function. This way, every time we invoke counter it has access to the numOfExecutions variable. The fact that we are not re-running createCounter and only run counter let us persist numOfExecutions across executions of counter, thus allow counter to be stateful, meaning we can share data with multiple executions of this function.

If we debug counter‚Äôs execution we can see in the developer-tools that numOfExecutions is not stored in the local variable environment of counter but in it‚Äôs ‚ÄúClosure‚Äù scope, (refers to as [[Scope]] in the spec).

![](https://www.debuggr.io/static/c12daf3075a67fdc790a86b2192f4c32/3d8bd/closure-debug.png)

But what if we wanted to return an object and not a function?

No problem, it will still work as expected:

```
function createCounter() {
  let count = 0;

  function increment() {
    count++;
    return count;
  }

  function decrement() {
    count--;
    return count;
  }

  function reset() {
    count = 0;
  }

  function log() {
    console.log(count)
  }

  const counterObj = {
    increment,
    decrement,
    reset,
    log
  }

  return counterObj;
}

const counter = createCounter();

counter.increment()
counter.increment()
counter.increment()

counter.log() // 3
```

‚òùÔ∏è By the way, this pattern is usually called the ‚ÄúModule Pattern‚Äù.

As you can see, it doesn‚Äôt matter what we are returning, it doesn‚Äôt matter where or when we are calling the functions, the only thing matters is where did we defined our functions:

> **WHERE** you define your function, determines what variables the function have access to **WHEN** it gets called.

Another bonus we get from returning a function or an object with functions is that we can create multiple instances of counter, each will be stateful and share data across executions but won‚Äôt conflict between other instances:

```
function createCounter() {
  let numOfExecutions = 0;

  function counter() {
    numOfExecutions++;
    console.log(numOfExecutions);
  }

  return counter;
}

const counter1 = createCounter();
const counter2 = createCounter();

counter1() // 1
counter1() // 2

counter2() // 1
counter2() // 2
```

As you can see, counter1 and counter2 are both stateful but are not conflicting with each others data, something we couldn‚Äôt do with a global variable.

## Optimizations

Every returned function is closing over the ENTIRE lexical scope, meaning the entire lexical scope won‚Äôt be garbage collected ü§î. This seems like a waste of memory and even a potential memory leak bug, should we re-consider the use of closures every time we need staeful functions?

Well, no. Most if not all browsers are optimizing this mechanism, meaning that in most cases only the variables that your function is actually using will be attached to the function‚Äôs [[scope]]. Why in most cases and not all cases? Because in some cases the browser is unable to determine what variables the function is using, such as in case of using eval. Obviously this is the smallest concern of using eval, it is safer to use Function constructor instead.

## Wrapping up

We learned about how ‚ÄúClosure‚Äù works under the hood, with a link to the surrounding lexical context. We saw that scope wise, it doesn‚Äôt matter when or where we are running our functions but where we are defining them, in other words: Lexical (static) binding. When we return a function, we actually returning not only the function but attach to it the entire lexical variable environment of all surrounding contexts (which browsers optimize and attach only referenced variables). This gives us the ability to create stateful functions with shared data across executions, it also allows us to create ‚Äúprivate‚Äù variables that our global execution context doesn‚Äôt have access to.

Hope you found this article helpful, if you have something to add or any suggestions or feedbacks I would love to hear about them, you can tweet or DM me @sag1v. ü§ì

Share this article